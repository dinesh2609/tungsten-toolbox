#!/usr/bin/perl
#
# The Tungsten Sandbox
# (C) 2011-2014 Giuseppe Maxia, Continuent, Inc
# Released under the New BSD License
#

use strict;
use warnings;
use File::Basename;
use English '-no_match_vars';
use Data::Dumper;

{
package Sandbox;
# SBVERSION
our $VERSION = '3.0.10';
use English '-no_match_vars';
use File::Basename;

my $modulepath= get_real_path($PROGRAM_NAME);
eval qq(
use lib '$modulepath';
use CLI_Utils;
use base qw(CLI_Utils);
);

sub modulepath
{
    return $modulepath;
}

sub get_version
{
    return $VERSION;
}
sub get_credits
{
    return   "Tungsten Sandbox Manager\n"
           . "version $VERSION\n"
           . "(C) Continuent, Inc, 2012,2013,2014\n";
}

sub get_layout
{
    return   "[options]";
}

sub get_real_path
{
    my ($fname) = @_;
    my $real_path=dirname($fname);
    if ( -l $fname)
    {
        my $real_name = qx(readlink $fname);
        chomp $real_name;
        # print "# program_name: $real_name\n";
        $real_path=dirname($real_name);
    }
    return $real_path;
}

}  # end package Sandbox

package main;

use Data::Dumper;

my $cli = Sandbox->new(
    {
        program_name => 'tungsten-sandbox',
        main_option  => undef,
    }
);

$cli->add_option(
    nodes => {
        parse       => 'n|nodes=i',
        value       => 0,
        must_have   => 1,
        so          => 10,
        help        => ['Defines how many nodes will be in the sandbox'],
    }
);

$cli->add_option(
    mysql_version => {
        parse       => 'm|mysql-version=s',
        value       => undef,
        must_have   => 1,
        so          => 20,
        help        => ['which MySQL version will be used for the sandbox'],
    }
);

$cli->add_option(
    tungsten_base => {
        parse       => 't|tungsten-base=s',
        value       => "$ENV{HOME}/tsb3",
        must_have   => 0,
        so          => 30,
        help        => ['Where to install the sandbox'],
    }
);

$cli->add_option(
    staging_dir => {
        parse       => 'i|staging-dir=s',
        value       => undef,
        must_have   => 0,
        so          => 40,
        help        => ['Where the Tungsten tarball was expanded'],
    }
);

$cli->add_option(
    group_dir => {
        parse       => 'd|group-dir=s',
        value       => 'tsb',
        must_have   => 0,
        so          => 50,
        help        => ['Sandbox group directory name'],
    }
);

$cli->add_option(
    topology => {
        parse       => 'topology=s',
        value       => 'master_slave',
        must_have   => 1,
        allowed     => [qw(master_slave all_masters fanin star direct)],
        so          => 60,
        help        => ['Which topology to deploy'],
    }
);

$cli->add_option(
    service => {
        parse       => 'service=s',
        value       => 'tsandbox',
        must_have   => 1,
        so          => 70,
        help        => ['How the service is named (in master/slave)'],
    }
);

$cli->add_option(
    mysql_port => {
        parse       => 'p|base-port=i',
        value       => 6000,
        must_have   => 1,
        so          => 80,
        help        => ['Base port for MySQL servers'],
    }
);

$cli->add_option(
    rmi_port => {
        parse       => 'r|rmi-port=i',
        value       => 10100,
        must_have   => 1,
        so          => 90,
        help        => ['Base port for RMI services'],
    }
);

$cli->add_option(
    thl_port => {
        parse       => 'l|thl-port=i',
        value       => 12100,
        must_have   => 1,
        so          => 100,
        help        => ['Base port for THL services'],
    }
);

$cli->add_option(
    defaults_options => {
        parse       => 'defaults-options=s',
        value       => undef,
        must_have   => 0,
        so          => 110,
        help        => ['Options that with be added to "tpm configure defaults" call'],
    }
);


$cli->add_option(
    master_options => {
        parse       => 'master-options=s',
        value       => undef,
        must_have   => 0,
        so          => 120,
        help        => ['Options that with be added to "tpm configure" call for a master service'],
    }
);

$cli->add_option(
    slave_options => {
        parse       => 'slave-options=s',
        value       => undef,
        must_have   => 0,
        so          => 130,
        help        => ['Options that with be added to "tpm configure" call for a slave service'],
    }
);

$cli->add_option(
    install_options => {
        parse       => 'install-options=s',
        value       => undef,
        must_have   => 0,
        so          => 140,
        help        => ['Options that with be added to "tpm install" calls for the current topology'],
    }
);

$cli->add_option(
    heterogenous_master => {
        parse       => 'hm|heterogenous-master',
        value       => $ENV{HETEROGENOUS_MASTER} || 0,
        must_have   => 0,
        so          => 142,
        help        => ['Sets every master service with heterogenous options'],
    }
);


$cli->add_option(
    heterogenous_slave => {
        parse       => 'hs|heterogenous-slave',
        value       => $ENV{HETEROGENOUS_SLAVE} || 0,
        must_have   => 0,
        so          => 144,
        help        => ['Sets every slave service with heterogenous options'],
    }
);



$cli->add_option(
    binlog_format => {
        parse       => 'binlog-format=s',
        value       => $ENV{BINLOG_FORMAT} || 'mixed',
        must_have   => 0,
        allowed     => [qw(STATEMENT MIXED ROW statement mixed row)],
        so          => 150,
        help        => ['Which binlog format shall we use'],
    }
);

$cli->add_option(
    use_ini_files => {
        parse       => 'use-ini-files',
        value       => 0,
        must_have   => 0,
        so          => 160,
        help        => ['Uses .INI files instead of staging directory to run the installation'],
    }
);


$cli->add_option(
    dry_run => {
        parse       => 'dry-run',
        value       => 0,
        must_have   => 0,
        so          => 170,
        help        => ['Shows the installation commands, without doing anything'],
    }
);

$cli->add_option(
    debug => {
        parse       => 'debug',
        value       => $ENV{CLI_DEBUG} || $ENV{SB_DEBUG} || 0,
        must_have   => 0,
        so          => 180,
        help        => ['Shows debug information during the installation'],
    }
);

$cli->getoptions();
$cli->{options}{tungsten_sandbox_version} = $Sandbox::VERSION;
$cli->get_help() if $cli->{options}{help};
# print Dumper $cli->{options}; exit;

my %min_nodes_by_topology =(
    master_slave => 2,
    all_masters  => 2,
    star         => 3,
    fanin        => 3,
    direct       => 2,
);
my $topology = $cli->{options}{topology};
unless ($cli->{options}->{nodes})
{
    $cli->{options}->{nodes}= $min_nodes_by_topology{$topology} ;
    if ($ENV{TEST_ALL_TOPOLOGIES})
    {
        $cli->{options}->{nodes} += 1;
    }
}

make_dynamic_options($cli->{options});

my $executable_path=Sandbox::get_real_path($PROGRAM_NAME);
my $curdir= $ENV{PWD};
chdir $executable_path;
$executable_path=qx(pwd);
chomp $executable_path;
chdir $curdir;

my $args = $cli->{options}->{nodes};

if ($topology eq 'master_slave' or $topology eq 'direct')
{
    $args= "$cli->{options}{service} $cli->{options}{nodes}";
}
# print "<$excutable_path/sb_$topology $args>\n";
if ($cli->{options}{staging_dir})
{
    chdir $cli->{options}{staging_dir};
}

if ($cli->{options}{verbose})
{
    $ENV{VERBOSE}=1;
}
if ($cli->{options}{debug})
{
    $ENV{SBDEBUG}=1;
}

if ($cli->{options}{dry_run})
{
    $ENV{DRYRUN}=1;
}
$ENV{RUNNING_SANDBOX_WRAPPER}=1;

if ($cli->{options}{use_ini_files})
{
    my @existing_ini_files = glob ("$cli->{options}{tungsten_base}/tungsten-node?.ini");
    if (@existing_ini_files)
    {
        die "Found pre-existing .ini files : (@existing_ini_files)\n";
    }
    if (exists $ENV{USE_INI})
    {
        delete $ENV{USE_INI};
    }
    $ENV{MAKE_INI}=1;
    $ENV{DRYRUN}=1;
    if ($cli->{options}{debug})
    {
        system "$executable_path/sb_$topology $args";
    }
    else
    {
        system "$executable_path/sb_$topology $args > /dev/null 2>&1";
    }
    delete $ENV{MAKE_INI};
    delete $ENV{DRYRUN};
    $ENV{USE_INI}=1;
}
# print "$executable_path/sb_$topology $args\n";
exec "$executable_path/sb_$topology $args";

sub make_dynamic_options
{
    my ($options) = @_;
    my %options_to_vars =(
        tungsten_sandbox_version => 'TUNGSTEN_SANDBOX_VERSION',
        nodes                    => 'HOW_MANY_NODES',
        mysql_version            => 'MYSQL_VERSION',
        tungsten_base            => 'TUNGSTEN_SB',
        group_dir                => 'MYSQL_SB_BASE',
        mysql_port               => 'MYSQL_BASE_PORT',
        rmi_port                 => 'RMI_BASE_PORT',
        thl_port                 => 'THL_BASE_PORT',
        defaults_options         => 'MORE_DEFAULTS_OPTIONS',
        master_options           => 'MORE_MASTER_OPTIONS',
        slave_options            => 'MORE_SLAVE_OPTIONS',
        install_options          => 'MORE_TPM_INSTALL_OPTIONS',
        binlog_format            => 'BINLOG_FORMAT',
    );
    if ($options->{heterogenous_master})
    {
        $options->{master_options}  = "" unless $options->{master_options};
        $options->{master_options} .= " --enable-heterogenous-service=true";
        $options->{binlog_format}   = "row";
        if ($CLI_Utils::VERBOSE)
        {
            print qq(# expanded --heterogenous-master into \n),
                  qq(# --master-options="$options->{master_options}"\n),
                  qq(# --binlog-format="$options->{binlog_format}"\n);
        }
    }

    if ($options->{heterogenous_slave})
    {
        $options->{slave_options} = "" unless $options->{slave_options};
        $options->{slave_options} .= " --enable-heterogenous-service=true";
        if ($CLI_Utils::VERBOSE)
        {
            print qq(# expanded --heterogenous-slave into \n),
                  qq(# --slave-options="$options->{slave_options}"\n);
        }
    }


    my $dynamic_vars_file =  Sandbox::modulepath() . '/sb_dynamic_vars.sh';
    # print "$dynamic_vars_file\n";
    open my $DYNVARS, '>', $dynamic_vars_file
        or die "can't write to $dynamic_vars_file ($!)\n";

    for my $opt (keys %options_to_vars)
    {
        my $quote=q{};
        if (defined $options->{$opt} )
        {
            if ($options->{$opt} =~/\s/)
            {
                $quote=q{"};
            }
            print $DYNVARS qq(export $options_to_vars{$opt}=$quote$options->{$opt}$quote\n) ;
        }
    }
    close $DYNVARS;
}

__END__
